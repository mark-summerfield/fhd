# TODO since State() & SetState() work purely on data can add to
# fhd_test.go
# also test Monitored()

fhd.go
state.go
flag.go
consts.go

fhd_test.go

README.md

st.sh

# NOTE

The `fhd` package allows its clients to do the following (where _files_ is
short for "all files or one or more specified files" and _fid_ is short for
"one or more specified file identifiers, i.e., filename and sid (save ID)"):

- open: open (and create if needed) the initial `.fhd` with the given
  filename (in cli & gui this should default to `folder.fhd`);
- get state: get the state for _files_;
- set state: set the state for _files_ in the current folder (optionally
  including subfolders) to – monitored, unmonitored (for a previously
  monitored file), or ignored;
- save: save a snapshot of the monitored _files_ (“check in”) with a
  timestamp and an optional comment—this creates a new sid (save ID);
- query: return a list of _fids_ and datetimes for _files_;
- extract: extract any previously saved copy (using a unique generated
  filename or a given filename) for _fids_;
- rename: see below
- delete: delete one or more previously saved copies of a monitored file
  (thus forgetting parts of its history) for _fids_, and set the filenames'
  states to unmonitored.

    "config" bucket
    key string # e.g., key='format' value=1
    value any

    "states" bucket
	key filename string
	value state enum # monitored unmonitored ignored renamed

    "saves" bucket
	key sid int # > 0
	value bucket
	    key filename string # see below for special cases
	    value struct { 
		    blob []byte
		    flag byte # Raw | Patch | Gz | InOld
		    sha256 []byte
		    oldSid int # > 0 if content and sha256 are empty (see below)
		    oldFilename string # nonempty if oldSid > 0 AND oldFilename != filename
		    }


In a SAVES value's bucket there are two special non-filename keys
- *when datetime # save timestamp
- *comment string

The initial monitor creates the STATE and SAVES, populates STATE setting
state to monitored and then does a save. It creates a new sid and
corresponding value bucket and sets the bucket's `*when` and `*comment`
and for each file adds the filename as key and sets its value struct's
content to the file's content, sha256 to the content's sha256, and the
oldSid to 0.

On subsequent saves the filenames to use are all those in STATE whose
state is monitored. For each file to save generate its sha256 and
compare that with the sha256s of its predecessor (or predecessor's
predecessor if its predecessor's oldSid > 0, and so on) - if a match is
found, set content and sha256 to empty and oldSid to the matched one;
otherwise populate content and the sha256 and set oldSid to 0.

Renaming
- create a new save, and in value bucket key=newfilename,
  value content = sha256 = empty, oldSid & oldFilename point to previous
  save's sid and filename
- in states, set oldname's state to Renamed; add newname with state of
  Monitored


# vim: syn=yaml
